<!DOCTYPE html>
<html>

<head>
    <title>Ping Pong Game</title>
    <link rel="stylesheet" href="styles.css">
    <meta name="viewport" content="width=device-width, initial-scale=1">
</head>

<body>
    <div id="main">
        <div id="controls">
            <div>
                Player 1
                <div>
                    <input type="radio" name="p1" id="p1-bot">
                    <label for="p1-bot">Bot</label>
                </div>
                <div>
                    <input type="radio" name="p1" id="p1-hum">
                    <label for="p1-hum">Human</label>
                </div>
            </div>
            <div>
                Player 2
                <div>
                    <input type="radio" name="p2" id="p2-bot">
                    <label for="p2-bot">Bot</label>
                </div>
                <div>
                    <input type="radio" name="p2" id="p2-hum">
                    <label for="p2-hum">Human</label>
                </div>
            </div>
        </div>
        <div id="canvas-container">
            <canvas id="canvas"></canvas>
        </div>
    </div>



    <span id="paused-overlay">Game Paused</span>
    <script type="text/javascript" src="js/app.js"></script>
    <script type="text/javascript">
        const PADDLE_MARGIN_MULTIPLIER = 4;
        const PADDLE_HEIGHT = 70;
        const PADDLE_WIDTH = 5;
        const BALL_SIZE = 8;
        const PLAYER_SPEED_MULTIPLIER = 4;
        const BALL_SPEED_MULTIPLIER = 5;
        const SCOREBOARD_OFFSET_X = 60;
        const SCOREBOARD_OFFSET_Y = 20;

        let containerBox = document.querySelector('#canvas-container').getBoundingClientRect();
        let canvas = document.querySelector('canvas');
        let X_MIN = 0;
        let Y_MIN = 0;
        let X_MAX = containerBox.width;
        let Y_MAX = containerBox.height;

        console.log([X_MIN, X_MAX, Y_MIN, Y_MAX])

        class Entity {
            constructor(x, y, id, color) {
                this.x = x;
                this.y = y;
                this.id = id;
                this.color = color;
            }
        }

        class Paddle extends Entity {
            constructor(x, y, id, color, isBot) {
                super(x, y, id, color);
                this.height = PADDLE_HEIGHT;
                this.width = PADDLE_WIDTH;
                this.isBot = false || isBot;
            }
        }

        class Ball extends Entity {
            constructor(x, y, id, color, dx, dy) {
                super(x, y, id, color);
                this.height = BALL_SIZE;
                this.width = BALL_SIZE;
                this.dx = dx || 1;
                this.dy = dy || 1;
            }
        }

        function getInitialState() {
            return {
                paused: false,
                pressedKeys: {
                    w: false,
                    s: false,
                    up: false,
                    down: false
                },
                player1: new Paddle(
                    (X_MAX / 100) * PADDLE_MARGIN_MULTIPLIER,
                    (Y_MAX / 2) - (PADDLE_HEIGHT / 2),
                    'player1',
                    'red',
                    true
                ),
                player2: new Paddle(
                    X_MAX - ((X_MAX / 100) * PADDLE_MARGIN_MULTIPLIER) - PADDLE_WIDTH,
                    (Y_MAX / 2) - (PADDLE_HEIGHT / 2),
                    'player2',
                    'black'),
                ball: new Ball(
                    Math.round(X_MAX / 2),
                    Math.round(Y_MAX / 2),
                    'ball',
                    'green',
                    getRandomInt(0, 1) === 0 ? -1 : 1,
                    getRandomInt(0, 1) === 0 ? -1 : 1
                ),
                score: {
                    player1: 0,
                    player2: 0
                },
                speeds: {
                    player1: PLAYER_SPEED_MULTIPLIER,
                    player2: PLAYER_SPEED_MULTIPLIER,
                    ball: BALL_SPEED_MULTIPLIER
                }
            };
        }

        let state = getInitialState();

        function getRandomInt(min, max) {
            min = Math.ceil(min);
            max = Math.floor(max);
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }

        function updateState(pressedKeys) {
            console.log(Y_MAX)
            const ball = state.ball;
            const [player1, player2] = [state.player1, state.player2];

            // Check left wall collision
            if (ball.x <= X_MIN) {
                state.score.player2++;
                app.reset();
                console.log(`Score ${state.score.player1} - ${state.score.player2}`);
                return;
            }

            // Check right wall collision
            if ((ball.x + ball.width) >= X_MAX) {
                state.score.player1++;
                app.reset();
                console.log(`Score ${state.score.player1} - ${state.score.player2}`);
                return;
            }

            // Check paddle collisions
            if (
                // Left paddle
                (ball.x >= player1.x
                    && ball.x <= (player1.x + player1.width)
                    && ball.y >= player1.y
                    && ball.y <= (player1.y + player2.height))
                // Right paddle
                || ((ball.x + ball.width) >= player2.x
                    && (ball.x + ball.width) <= (player2.x + player2.width)
                    && ball.y >= player2.y
                    && ball.y <= (player2.y + player2.height))
            ) {
                ball.dx = -ball.dx;
            }

            // Check floor/ceiling collision
            if (ball.y <= Y_MIN // ceiling hit
                || (ball.y + ball.height) >= Y_MAX) { // floor hit
                ball.dy = -ball.dy;
            }

            // Update ball position
            ball.x = ball.x + (ball.dx * state.speeds.ball);
            ball.y = ball.y + (ball.dy * state.speeds.ball);

            // Update paddle positions
            for (const [k, v] of Object.entries(pressedKeys)) {
                if (!player1.isBot) {
                    if (k === 'w' && v) {
                        const y = Math.max(player1.y - state.speeds.player1, Y_MIN);
                        player1.y = y;
                    }
                    if (k === 's' && v) {
                        const y = Math.min(player1.y + state.speeds.player1, Y_MAX - player1.height);
                        player1.y = y;
                    }
                }
                if (!player2.isBot) {
                    if (k === 'up' && v) {
                        const y = Math.max(player2.y - state.speeds.player2, Y_MIN);
                        player2.y = y;
                    }
                    if (k === 'down' && v) {
                        const y = Math.min(player2.y + state.speeds.player2, Y_MAX - player2.height);
                        player2.y = y;
                    }
                }
            }

            if (player1.isBot) {
                if (ball.dy === -1) {
                    player1.y = Math.max(player1.y - state.speeds.player1, Y_MIN)
                } else {
                    player1.y = Math.min(player1.y + state.speeds.player1, Y_MAX - player1.height)
                }
            }

            if (player2.isBot) {
                if (ball.dy === -1) {
                    player2.y = Math.max(player2.y - state.speeds.player2, Y_MIN)
                } else {
                    player2.y = Math.min(player2.y + state.speeds.player2, Y_MAX - player2.height)
                }
            }
        }

        function drawState(app) {
            // Draw entity positions
            app.getNode('player1').x = state.player1.x;
            app.getNode('player1').y = state.player1.y;
            app.getNode('player2').x = state.player2.x;
            app.getNode('player2').y = state.player2.y;
            app.getNode('ball').x = state.ball.x;
            app.getNode('ball').y = state.ball.y;

            // Draw score
            app.context.fillStyle = 'black';
            app.context.font = '24px serif';
            app.context.fillText(
                `Score ${state.score.player1} - ${state.score.player2}`,
                X_MAX / 2 - SCOREBOARD_OFFSET_X,
                SCOREBOARD_OFFSET_Y + Y_MAX / 100 * 3
            );

            let overlay = document.getElementById('paused-overlay');
            if (state.paused) {
                overlay.style.visibility = 'visible';
            } else {
                overlay.style.visibility = 'hidden';
            }
        }

        app.reset = function () {
            state = {
                ...getInitialState(),
                score: state.score,
            };
        }

        app.pause = function () {
            state.paused = !state.paused;
        }

        app.onInit = function () {
            containerBox = document.querySelector('#canvas-container').getBoundingClientRect();
            X_MAX = containerBox.width;
            Y_MAX = containerBox.height;
            app.x = X_MIN;
            app.y = Y_MIN;
            app.width = X_MAX;
            app.height = Y_MAX;
            canvas.width = app.width;
            canvas.height = app.height;
            console.log([X_MIN, X_MAX, Y_MIN, Y_MAX])

            // Register keydown events
            document.addEventListener('keydown', e => {
                switch (e.keyCode) {
                    case 32: app.pause(); break; // spacebar
                    case 38: state.pressedKeys.up = true; break; // up arrow
                    case 40: state.pressedKeys.down = true; break; // down arrow
                    case 87: state.pressedKeys.w = true; break; // 'w'
                    case 83: state.pressedKeys.s = true; break; // 's'
                }
            });

            // Register keyup events
            document.addEventListener('keyup', e => {
                switch (e.keyCode) {
                    case 38: state.pressedKeys.up = false; break; // up arrow
                    case 40: state.pressedKeys.down = false; break; // down arrow
                    case 87: state.pressedKeys.w = false; break; // 'w'
                    case 83: state.pressedKeys.s = false; break; // 's'
                }
            });

            window.onresize = function () {
                containerBox = document.querySelector('#canvas-container').getBoundingClientRect();
                X_MAX = containerBox.width;
                Y_MAX = containerBox.height;
                app.x = X_MIN;
                app.y = Y_MIN;
                app.width = X_MAX
                app.height = Y_MAX;
                canvas.width = app.width;
                canvas.height = app.height;
                console.log([X_MIN, X_MAX, Y_MIN, Y_MAX])
                state.player1.x = (X_MAX / 100) * PADDLE_MARGIN_MULTIPLIER;
                state.player2.x = X_MAX - ((X_MAX / 100) * PADDLE_MARGIN_MULTIPLIER) - PADDLE_WIDTH;
            }


            // Initialize canvas nodes
            this.nodes.push(state.player1);
            this.nodes.push(state.player2);
            this.nodes.push(state.ball);
        };

        app.onUpdate = function (time) {
            if (!state.paused) {
                pressedKeys = { ...state.pressedKeys }; // Freeze so that updates can't occur while state is updating
                updateState(pressedKeys);
            }
            drawState(this);
        };
    </script>
</body>

</html>
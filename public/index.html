<!DOCTYPE html>
<html>

<head>
	<title>Ping Pong Game</title>
	<link rel="stylesheet" href="styles.css">
	<meta name="viewport" content="width=device-width, initial-scale=1">
</head>

<body>
	<canvas id="canvas"></canvas>
	<span id="paused-overlay">Game Paused</span>
	<script type="text/javascript" src="js/app.js"></script>
	<script type="text/javascript">

		const PADDLE_MARGIN_MULTIPLIER = 4;
		const PADDLE_HEIGHT = 70;
		const PADDLE_WIDTH = 5;
		const BALL_SIZE = 8;
		const PLAYER_SPEED_MULTIPLIER = 4;
		const BALL_SPEED_MULTIPLIER = 5;
		const SCOREBOARD_OFFSET_X = 60;
		const SCOREBOARD_OFFSET_Y = 20;
		const X_MIN = 0;
		const Y_MIN = 0;
		let X_MAX = window.innerWidth;
		let Y_MAX = window.innerHeight;

		class Entity {
			constructor(x, y, id, color) {
				this.x = x;
				this.y = y;
				this.id = id;
				this.color = color;
			}
		}

		class Paddle extends Entity {
			constructor(x, y, id, color) {
				super(x, y, id, color);
				this.height = PADDLE_HEIGHT;
				this.width = PADDLE_WIDTH;
			}
		}

		class Ball extends Entity {
			constructor(x, y, id, color, dx, dy) {
				super(x, y, id, color);
				this.height = BALL_SIZE;
				this.width = BALL_SIZE;
				this.dx = dx || 1;
				this.dy = dy || 1;
			}
		}

		function getInitialState() {
			return {
				paused: false,
				pressedKeys: {
					w: false,
					s: false,
					up: false,
					down: false
				},
				player1: new Paddle(
					(X_MAX / 100) * PADDLE_MARGIN_MULTIPLIER,
					(Y_MAX / 2) - (PADDLE_HEIGHT / 2),
					'player1',
					'red'
				),
				player2: new Paddle(
					X_MAX - ((X_MAX / 100) * PADDLE_MARGIN_MULTIPLIER) - PADDLE_WIDTH,
					(Y_MAX / 2) - (PADDLE_HEIGHT / 2),
					'player2',
					'black'),
				ball: new Ball(
					Math.round(X_MAX / 2),
					Math.round(Y_MAX / 2),
					'ball',
					'green',
					getRandomInt(0, 1) === 0 ? -1 : 1,
					getRandomInt(0, 1) === 0 ? -1 : 1
				),
				score: {
					player1: 0,
					player2: 0
				},
				speeds: {
					player1: PLAYER_SPEED_MULTIPLIER,
					player2: PLAYER_SPEED_MULTIPLIER,
					ball: BALL_SPEED_MULTIPLIER
				}
			};
		}

		let state = getInitialState();

		function getRandomInt(min, max) {
			min = Math.ceil(min);
			max = Math.floor(max);
			return Math.floor(Math.random() * (max - min + 1)) + min;
		}

		function updateState(pressedKeys) {
			const ball = state.ball;
			const [player1, player2] = [state.player1, state.player2];

			// Check left wall collision
			if (ball.x <= X_MIN) {
				state.score.player2++;
				app.reset();
				console.log(`Score ${state.score.player1} - ${state.score.player2}`);
				return;
			}

			// Check right wall collision
			if ((ball.x + ball.width) >= X_MAX) {
				state.score.player1++;
				app.reset();
				console.log(`Score ${state.score.player1} - ${state.score.player2}`);
				return;
			}

			// Check paddle collisions
			if (
				// Left paddle
				(ball.x >= player1.x
					&& ball.x <= (player1.x + player1.width)
					&& ball.y >= player1.y
					&& ball.y <= (player1.y + player2.height))
				// Right paddle
				|| ((ball.x + ball.width) >= player2.x
					&& (ball.x + ball.width) <= (player2.x + player2.width)
					&& ball.y >= player2.y
					&& ball.y <= (player2.y + player2.height))
			) {
				ball.dx = -ball.dx;
			}

			// Check floor/ceiling collision
			if (ball.y <= Y_MIN // ceiling hit
				|| (ball.y + ball.height) >= Y_MAX) { // floor hit
				ball.dy = -ball.dy;
			}

			// Update ball position
			ball.x = ball.x + (ball.dx * state.speeds.ball);
			ball.y = ball.y + (ball.dy * state.speeds.ball);

			// Update paddle positions
			for (const [k, v] of Object.entries(pressedKeys)) {
				if (k === 'w' && v) {
					const y = Math.max(player1.y - state.speeds.player1, Y_MIN);
					player1.y = y;
				}
				if (k === 's' && v) {
					const y = Math.min(player1.y + state.speeds.player1, Y_MAX - player1.height);
					player1.y = y;
				}
				if (k === 'up' && v) {
					const y = Math.max(player2.y - state.speeds.player2, Y_MIN);
					player2.y = y;
				}
				if (k === 'down' && v) {
					const y = Math.min(player2.y + state.speeds.player2, Y_MAX - player2.height);
					player2.y = y;
				}
			}
		}

		function drawState(app) {
			// Draw entity positions
			app.getNode('player1').x = state.player1.x;
			app.getNode('player1').y = state.player1.y;
			app.getNode('player2').x = state.player2.x;
			app.getNode('player2').y = state.player2.y;
			app.getNode('ball').x = state.ball.x;
			app.getNode('ball').y = state.ball.y;

			// Draw score
			app.context.fillStyle = 'black';
			app.context.font = '24px serif';
			app.context.fillText(
				`Score ${state.score.player1} - ${state.score.player2}`,
				X_MAX / 2 - SCOREBOARD_OFFSET_X,
				SCOREBOARD_OFFSET_Y + Y_MAX / 100 * 3
			);

			let overlay = document.getElementById('paused-overlay');
			if (state.paused) {
				overlay.style.visibility = 'visible';
			} else {
				overlay.style.visibility = 'hidden';
			}
		}
		app.reset = function () {
			state = {
				...getInitialState(),
				window: state.window,
				score: state.score,
			};
		}

		app.pause = function () {
			state.paused = !state.paused;
		}

		app.onInit = function () {
			// Register keydown events
			document.addEventListener('keydown', e => {
				switch (e.keyCode) {
					case 32: app.pause(); break; // spacebar
					case 38: state.pressedKeys.up = true; break; // up arrow
					case 40: state.pressedKeys.down = true; break; // down arrow
					case 87: state.pressedKeys.w = true; break; // 'w'
					case 83: state.pressedKeys.s = true; break; // 's'
				}
			});

			// Register keyup events
			document.addEventListener('keyup', e => {
				switch (e.keyCode) {
					case 38: state.pressedKeys.up = false; break; // up arrow
					case 40: state.pressedKeys.down = false; break; // down arrow
					case 87: state.pressedKeys.w = false; break; // 'w'
					case 83: state.pressedKeys.s = false; break; // 's'
				}
			});

			window.onresize = function () {
				X_MAX = window.innerWidth;
				Y_MAX = window.innerHeight;
				app.width = X_MAX;
				app.height = Y_MAX;
				app.canvas.width = X_MAX;
				app.canvas.height = Y_MAX;
				state.player1.x = (X_MAX / 100) * PADDLE_MARGIN_MULTIPLIER;
				state.player2.x = X_MAX - ((X_MAX / 100) * PADDLE_MARGIN_MULTIPLIER) - PADDLE_WIDTH;
			}

			// Define canvas dimensions
			app.width = X_MAX;
			app.height = Y_MAX;
			app.canvas.width = X_MAX;
			app.canvas.height = Y_MAX;

			// Initialize canvas nodes
			this.nodes.push(state.player1);
			this.nodes.push(state.player2);
			this.nodes.push(state.ball);
		};

		app.onUpdate = function (time) {
			if (!state.paused) {
				pressedKeys = { ...state.pressedKeys }; // Freeze so that updates can't occur while state is updating
				updateState(pressedKeys);
			}
			drawState(this);
		};
	</script>
</body>

</html>